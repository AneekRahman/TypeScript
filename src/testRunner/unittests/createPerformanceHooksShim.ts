/* eslint-disable @typescript-eslint/no-unused-expressions */ // chai's expect allows you to use dot-property assertions like `.is.empty`
namespace ts {
    describe("unittests:: createPerformanceHooksShim", () => {
        it("has expected API", () => {
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(Date.now);
            expect(performance).to.be.an("object");
            expect(performance.timeOrigin).to.be.a("number");
            expect(performance.clearMarks).to.be.a("function");
            expect(performance.mark).to.be.a("function");
            expect(performance.measure).to.be.a("function");
            expect(performance.now).to.be.a("function");
            expect(PerformanceObserver).to.be.a("function");
            let list!: PerformanceObserverEntryList;
            let observer2!: PerformanceObserver;
            const observer = new PerformanceObserver((_list, observer) => { list = _list; observer2 = observer; });
            expect(list).to.be.an("object");
            expect(observer2).to.be.an("object");
            expect(observer2).to.equal(observer);
            expect(observer2.disconnect).to.be.a("function");
            expect(observer2.observe).to.be.a("function");
            expect(list.getEntries).to.be.a("function");
            expect(list.getEntriesByName).to.be.a("function");
            expect(list.getEntriesByType).to.be.a("function");
        });
        it("only listens for events while connected", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);

            performance.mark("a");
            const entries1 = list.getEntries();
            observer.observe({ entryTypes: ["mark"] });
            performance.mark("b");
            const entries2 = list.getEntries();
            observer.disconnect();
            performance.mark("c");
            const entries3 = list.getEntries();

            expect(entries1).to.be.empty;
            expect(entries2).to.not.be.empty;
            expect(entries3).to.be.empty;
        });
        it("Can get entries by name and type (mark)", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntriesByName("a", "mark");
            const entries2 = list.getEntriesByName("b", "mark");
            observer.disconnect();
            expect(entries).to.have.lengthOf(1);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
            expect(entries2).to.be.empty;
        });
        it("Can get entries by name and type (measure)", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntriesByName("b", "measure");
            const entries2 = list.getEntriesByName("a", "measure");
            observer.disconnect();
            expect(entries).to.have.lengthOf(1);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("b");
            expect(entries[0].entryType).to.equal("measure");
            expect(entries2).to.be.empty;
        });
        it("Can get entries by name", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntriesByName("a");
            const entries2 = list.getEntriesByName("b");
            observer.disconnect();
            expect(entries).to.not.be.empty;
            expect(entries).to.have.lengthOf(1);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
            expect(entries2).to.have.lengthOf(1);
            expect(entries2[0]).to.be.an("object");
            expect(entries2[0].name).to.equal("b");
            expect(entries2[0].entryType).to.equal("measure");
        });
        it("Can get entries by type", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntriesByType("mark");
            const entries2 = list.getEntriesByType("measure");
            observer.disconnect();
            expect(entries).to.have.lengthOf(1);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
            expect(entries2).to.have.lengthOf(1);
            expect(entries2[0]).to.be.an("object");
            expect(entries2[0].name).to.equal("b");
            expect(entries2[0].entryType).to.equal("measure");
        });
        it("Can get entries", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries).to.have.lengthOf(2);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
            expect(entries[1]).to.be.an("object");
            expect(entries[1].name).to.equal("b");
            expect(entries[1].entryType).to.equal("measure");
        });
        it("Unobserved entries are ignored", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark"] });
            performance.mark("a");
            performance.measure("b", "a");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries).to.have.lengthOf(1);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
        });
        it("Changing what's observed only affects new entries", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark"] });
            performance.mark("a");
            performance.measure("b", "a");
            observer.observe({ entryTypes: ["measure"] });
            performance.mark("c");
            performance.measure("d", "c");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries).to.have.lengthOf(2);
            expect(entries[0]).to.be.an("object");
            expect(entries[0].name).to.equal("a");
            expect(entries[0].entryType).to.equal("mark");
            expect(entries[1]).to.be.an("object");
            expect(entries[1].name).to.equal("d");
            expect(entries[1].entryType).to.equal("measure");
        });
        it("mark tracks current time", () => {
            let timestamp = 0;
            const now = () => timestamp;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark"] });
            const ts1 = timestamp;
            performance.mark("a");
            timestamp++;
            const ts2 = timestamp;
            performance.mark("b");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries[0].startTime).to.equal(ts1);
            expect(entries[0].duration).to.equal(0);
            expect(entries[1].startTime).to.equal(ts2);
            expect(entries[1].duration).to.equal(0);
        });
        it("measure tracks time between marks", () => {
            let timestamp = 0;
            const now = () => timestamp;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark", "measure"] });
            const ts1 = timestamp;
            performance.mark("a");
            timestamp++;
            const ts2 = timestamp;
            performance.mark("b");
            performance.measure("c", "a", "b");
            const entries = list.getEntriesByType("measure");
            observer.disconnect();
            expect(entries[0].startTime).to.equal(ts1);
            expect(entries[0].duration).to.equal(ts2 - ts1);
        });
        it("measure tracks time between unobserved marks", () => {
            let timestamp = 0;
            const now = () => timestamp;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["measure"] });
            const ts1 = timestamp;
            performance.mark("a");
            timestamp++;
            const ts2 = timestamp;
            performance.mark("b");
            performance.measure("c", "a", "b");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries[0].startTime).to.equal(ts1);
            expect(entries[0].duration).to.equal(ts2 - ts1);
        });
        it("marks can be counted", () => {
            let timestamp = 0;
            const now = () => timestamp++;
            const { performance, PerformanceObserver } = ShimPerformance.createPerformanceHooksShim(now);
            let list!: PerformanceObserverEntryList;
            const observer = new PerformanceObserver(_list => list = _list);
            observer.observe({ entryTypes: ["mark"] });
            performance.mark("a");
            performance.mark("a");
            performance.mark("a");
            const entries = list.getEntries();
            observer.disconnect();
            expect(entries).to.have.lengthOf(3);
        });
    });
}